<html><script src="raphael-min.js"></script><script>
/*******************************************************************************

kOpt: graph optimization for minimum distance
JSYANG.CA
17/09/2010

*******************************************************************************/

// simplification edit: keep it bare!

function Node(x,y){
	this.x=x;
	this.y=y;
}

function Tour(nodes){
	this.nodes=nodes;
	this.dist=function(n){
		var d=0; if(!n.length) return d;
		var prevNode;
		for(var i in n){
			var ni=n[i];
		    if(!prevNode){ prevNode=ni; continue; } // skip the first one
			var yd=prevNode.y-ni.y;
			var xd=prevNode.x-ni.x;
			d+=Math.sqrt(xd*xd+yd*yd);
			prevNode=ni;
		}
		yd=n[0].y-prevNode.y;
		xd=n[0].x-prevNode.x;
		d+=Math.sqrt(xd*xd+yd*yd);
		return d;
	};
	this.lastDist=this.dist(nodes);
}
			

// 	TOUR(collection of nodes in sequence) > NODE

/*********************** DATA GENERATION, manipulation ************************/

function makeNodes(n,xRange,yRange){
	var nodes=[];
	var r=Math.random;
	var f=Math.floor;
	
	var xd=xRange[1]-xRange[0];
	var yd=yRange[1]-yRange[0];
	
	// generate a property within that property's range
	var gX=function(){ return xRange[0]+f(r()*xd); };
	var gY=function(){ return yRange[0]+f(r()*yd); };
	
	while(n-->0) nodes.push(new Node(gX(),gY()));
	return nodes;
}

/*************************** K-OPT ALGORITHM METHODS ************************/


function kopt2l( tour, i, j ){
    if( !(i<tour.nodes.length) || !(j<tour.nodes.length) || i==j ) return;
        
    var r0=tour.nodes.slice(0);
    var r=[];

    // don't just swap the two nodes at the indices, you will still have a knot
    // elsewhere, if you don't inverse either the "interior" or the "exterior"

    
    // flip the insides/outsides
    var lower=(j>i)? i : j;
    var upper=(j>i)? j : i;
    var r_head=r0.slice(0,lower);
    var r_body=r0.slice(lower,upper);
    var r_tail=r0.slice(upper);
    r=r.concat(r_head);
    r=r.concat(r_body.reverse());
    r=r.concat(r_tail);

    var oldDist=tour.lastDist;
    var newDist=tour.dist(r);
    if(newDist<oldDist){
        tour.nodes=r;
        tour.lastDist=newDist;
    }
    return tour.lastDist;
}

// 3-opt has a MOVE and a SPLIT heuristic
// this is only implementing MOVE, as there's no support for split yet
// -- only dealing with 1 tour/trip at a time

function kopt3( tour, i, j, s ){

    if( !s ) return;                            // no shift 
    if( j <=0 ) return;                         // empty segment! wtf are you doing!
    if( i+j > tour.nodes.length ) return;       // segment exceeds the length of the tour

    // i = starting index of the segment
    // j = length of the segment
    // s = shift index

    

    var r0=tour.nodes.slice(0);
    var cut=r0.splice(i,j);                     // cut the segment out
    var r=r0.slice(0,i+s);                      // slice into the part where the cut will be inserted
    r=r.concat(cut);                            // put the cut in
    r=r.concat(r0.slice(i+s));                  // add the tail back into the new array
    
    var oldDist=tour.lastDist;
    var newDist=tour.dist(r);
    if(newDist<oldDist){
        tour.nodes=r;
        tour.lastDist=newDist;
    }
    return tour.lastDist;
    
}

/******************************* inst. execution ******************************/


var g;  // canvas
var t;  // tour
var koptI=[0,0];

function drawTour(tour){
    g.clear();
    var prevNode;
    for( var i in tour.nodes ){
        var n=tour.nodes[i];
        var c=g.circle(n.x,n.y,3);
        c.attr({fill:"#034"});
        if(!!prevNode) g.path("M"+prevNode.x+" "+prevNode.y+"L"+n.x+" "+n.y);
        prevNode=n;
    }
    // draw the edge from last to first node
    g.path("M"+prevNode.x+" "+prevNode.y+"L"+t.nodes[0].x+" "+t.nodes[0].y);
}

/*
var KO_1iteration=function(){
    kopt2l(t,koptI[0],koptI[1]);
    koptI[1]++;
    if(koptI[1]>t.nodes.length-1){
        koptI[0]++;
        koptI[1]=0;
    }
    if(koptI[0]>t.nodes.length-1){
        koptI[0]=0;
        koptI[1]=1;
    }
    document.title=koptI;
    drawTour(t);
};
*/

var KO2_1cycle=function(){
    for(var i=0; i<t.nodes.length; i++){
        for(var j=1; j<t.nodes.length; j++){
            if(i!=j) kopt2l(t,i,j);
        }
    }
    drawTour(t);
};

var KO3_1cycle=function(){
    var nl=t.nodes.length;
    for(var i=0; i<nl; i++){
        for(var j=1; j<nl-i; j++){
            for(var s=-i; s<=nl-j-i; s++){
                if(s) kopt3( t, i, j, s );
            }
        }
    }
    drawTour(t);
}
/*************************** miscellaneous output functions *******************/    
// for Concorde TSP solver

function getTSPLIB(t){
    var s=
        "NAME : jsyang \n"+
        "COMMENT : Nodes generated by jsyang \n"+
        "TYPE : TSP \n"+
        "DIMENSION : "+t.nodes.length+" \n"+
        "EDGE_WEIGHT_TYPE : CEIL_2D \n"+
        "NODE_COORD_SECTION\n";
    for(var i in t.nodes){
        s+=" "+(parseInt(i)+1)+" "+t.nodes[i].x+" "+(-t.nodes[i].y)+"\n";
    }
    return s+"EOF\n";
}

/******************************************************************************/

window.onload=function(){
    t = new Tour(makeNodes(30,[0,700],[0,300]));
    g = Raphael(0,0,800,600);

	drawTour(t);
	
	//window.onmousemove=    
    window.onclick=KO2_1cycle;
};

</script><body><div id="body"></div></body></html>
