<html><style>canvas{border:dashed #000 1px;}</style><body></body><script src=gLayer.js></script><script>
/*//////////////////////////////////////////////////////////////////////////////

    kOpt: Traveling Salesmen Problem heuristics    
    jsyang.ca@gmail.com

    Sept. 17, 2010          Original implementation
    Apr. 3, 2011            Removed dependency on raphael.js,
                            refactored everything.

//////////////////////////////////////////////////////////////////////////////*/

function Loc(x,y)
{
    this.x=x;
    this.y=y;
    
    this.distTo=function(otherLoc)
    {
        var yd=this.y-otherLoc.y;
        var xd=this.x-otherLoc.x;
        return Math.sqrt(xd*xd+yd*yd);
    };
}

function Tour(locs)
{
    this.locs=locs;    
    this.dist=function(locs)
    {
        var distance=0;
        if(!!locs.length)
        {        
            for(var i=0, prevLoc=0; i<locs.length; prevLoc=locs[i], i++)
            {
                if(!i) continue;
                distance+=prevLoc.distTo(locs[i]);
            }           
            distance+=prevLoc.distTo(locs[0]);
        }        
        return distance;
    };
    this.lastDist=this.dist(locs);
    this.update=function(newLocs)
    {
        var newDist=this.dist(newLocs);
        if(newDist>=this.lastDist) return;
        this.locs=newLocs;
        this.lastDist=newDist;
    };
}

// Generate a random Location sequence for a Tour //////////////////////////////

function randomLocs(n,xRange,yRange)
{
    var locs=[];
    var r=Math.random;
    var f=Math.floor;    
    var xd=xRange[1]-xRange[0];
    var yd=yRange[1]-yRange[0];        
    var gX=function(){ return xRange[0]+f(r()*xd); };
    var gY=function(){ return yRange[0]+f(r()*yd); };
    
    while(n-->0) locs.push(new Loc(gX(),gY()));
    return locs;
}

// KOpt Heuristics /////////////////////////////////////////////////////////////

function kopt2_FLIP(tour,i,j)
{
    if( !(i<tour.locs.length) || !(j<tour.locs.length) || i==j ) return;

    var r0=tour.locs.slice(0);
    var r=[];

    // Flip the inside / outside.
    var lower=(j>i)? i : j;
    var upper=(j>i)? j : i;
    var r_head=r0.slice(0,lower);
    var r_body=r0.slice(lower,upper);
    var r_tail=r0.slice(upper);
    r=r.concat(r_head);
    r=r.concat(r_body.reverse());
    r=r.concat(r_tail);
    
    tour.update(r);
}

function kopt3_MOVE(tour,i,j,shift)
//  i       Starting index of the segment
//  j       Segment length
//  shift   Where to shift to the new position
{
    if( !shift || j <=0 || i+j > tour.locs.length ) return;    

    // MOVE the segment to a new place in the Tour.
    var r0=tour.locs.slice(0);
    var cut=r0.splice(i,j);
    var r=r0.slice(0,i+shift);
    r=r.concat(cut);
    r=r.concat(r0.slice(i+shift));
    
    tour.update(r);
}

// Set up some graphics stuff //////////////////////////////////////////////////

var initialDist;
var t;
var t_;
var divDist;

var g=new gLayer([],[800,500],function(o)
{    
    document.body.appendChild(document.createElement("br"));
    document.body.appendChild(document.createElement("br"));
    divDist=document.createElement("div");
    document.body.appendChild(divDist);
    
    var div=document.createElement("div");
    div.innerHTML=
    "<hr><a href=javascript:KOPT2_1CYCLE()>Run a 2-Opt SWAP cycle</a><br>"+
    "<a href=javascript:KOPT3_MOVE_1CYCLE()>Run a 3-Opt MOVE cycle</a><br>"+
    "<a href=javascript:REVERT_TOUR()>Revert to the initial tour</a>";
    document.body.appendChild(div);
    
    t_=randomLocs(50,[0,o.w],[0,o.h]);
    t=new Tour(t_);
    
    initialDist=t.lastDist;
    // Draw our initial state.
    setTimeout("drawTour(t)",200);
});

function drawTour(tour)
{   
    g.clear();
    g.c.beginPath();
    for( var i=0; i<tour.locs.length; i++ )
    {
        var n=tour.locs[i];
        g.c.fillRect(n.x-2,n.y-2,4,4);
        if(!i)
        {
            g.c.moveTo(n.x,n.y);
            continue;
        }
        g.c.lineTo(n.x,n.y);
    }
    g.c.lineTo(tour.locs[0].x,tour.locs[0].y);
    g.c.stroke();
    
    divDist.innerHTML="Tour distance: "+Math.round(t.lastDist)+
    " ["+((t.lastDist*10000/initialDist)>>0)*0.01+"% original distance]";
}

// Cycle through the Tour to apply an iteration at every location //////////////

function KOPT2_1CYCLE()
{
    for(var i=0; i<t.locs.length; i++)
    for(var j=1; j<t.locs.length; j++)
    if(i!=j) kopt2_FLIP(t,i,j);    
    drawTour(t);
}

function KOPT3_MOVE_1CYCLE()
{
    var nl=t.locs.length;
    for(var i=0; i<nl; i++)
    for(var j=1; j<nl-i; j++)
    for(var s=-i; s<=nl-j-i; s++)
    if(s) kopt3_MOVE(t,i,j,s);    
    drawTour(t);
}

function REVERT_TOUR()
{    
    drawTour(t=new Tour(t_));
}

// for Concorde TSP solver -- to double check the results //////////////////////
function getTSPfile(t)
{
    var l=t.locs;
    var s=
    "NAME : jsyang \n"+
    "COMMENT : Vertices generated by jsyang \n"+
    "TYPE : TSP \n"+
    "DIMENSION : "+l.length+" \n"+
    "EDGE_WEIGHT_TYPE : CEIL_2D \n"+
    "NODE_COORD_SECTION\n";
        
    for(var i in l) s+=" "+(parseInt(i)+1)+" "+l[i].x+" "+(-l[i].y)+"\n";

    return s+"EOF\n";
}

</script></html>
